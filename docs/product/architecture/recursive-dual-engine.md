---
sidebar_position: 1
title: Recursive Dual-Engine
---

# Recursive Dual-Engine Architecture

The core innovation of Memfit AI lies in the non-linear nesting relationship between two engines: the **Plan Engine** (Strategic Layer) and the **ReAct Engine** (Tactical Layer).

## Plan Engine (Strategic Layer)

The Plan Engine is responsible for the macroscopic deconstruction of tasks. When facing complex, ambiguous, or long-cycle user intentions, the system initiates the planning engine to:

- Dismantle top-level goals into a structured **Task Tree**
- Establish temporal dependencies between subtasks
- Define logical associations and execution order
- Provide a global vision and execution skeleton

This prevents the Agent from losing direction during long-chain operations.

## ReAct Engine (Tactical Layer)

The ReAct Engine is responsible for the dynamic execution of atomic tasks. For each subtask, the system instantiates an independent **ReAct Loop** that operates through:

1. **Observation** - Collect environment state and feedback
2. **Thought** - Reason about the current situation
3. **Action** - Execute the decided operation

This closed-loop mechanism endows the Agent with the ability to cope with non-deterministic environments.

## Recursive Coupling Mechanism

The true power of Memfit AI emerges from the recursive coupling between these two engines:

- When the ReAct engine encounters complex sub-problems beyond its current capabilities, it can dynamically trigger the Plan engine for **Sub-planning**
- Every leaf node task generated by the Plan engine is executed by the ReAct engine
- This recursive mechanism supports fractal expansion of tasks
- The system can adapt to business scenarios of arbitrary complexity

## Execution Flow

```
User Intent
    ↓
Coordinator
    ↓
Plan Engine → Task Tree Generation
    ↓
    ├── Subtask 1 → ReAct Loop
    │       ↓
    │   [Complex Problem?] → Yes → Sub-planning (Plan Engine)
    │                      → No  → Continue Execution
    │
    ├── Subtask 2 → ReAct Loop
    │
    └── Subtask N → ReAct Loop
```

## Benefits

1. **Scalability** - Handles tasks of any complexity level
2. **Flexibility** - Adapts to changing requirements during execution
3. **Reliability** - Each level has its own error handling and recovery
4. **Transparency** - Clear task decomposition for user review

