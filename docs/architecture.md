---
sidebar_position: 1
title: Architecture
---

# Memfit AI Architecture

Memfit AI breaks through the limitations of single paradigms by innovatively adopting a **Recursive Coupling of ReAct and Plan-Execute** hybrid architecture. This architecture organically fuses macroscopic **Strategic Planning** with microscopic **Tactical Execution** through a Coordinator, achieving a unity of determinism and flexibility in task processing.

This document details the core architecture design, data flow, key components, and the closed-loop mechanism of planning and execution.

## Recursive Dual-Engine Architecture

The core of Memfit AI lies in the non-linear nesting relationship between two engines: the **Plan Engine** (Strategic Layer) and the **ReAct Engine** (Tactical Layer).

*   **Plan Engine:** Responsible for the macroscopic deconstruction of tasks. Facing complex, ambiguous, or long-cycle user intentions, the system initiates the planning engine to dismantle top-level goals into a structured **Task Tree** with temporal dependencies and logical associations. This provides a global vision and execution skeleton.
*   **ReAct Engine:** Responsible for the dynamic execution of atomic tasks. For each subtask, the system instantiates an independent **ReAct Loop**, interacting with the environment through the "Observation - Thought - Action" closed loop. This endows the Agent with the ability to cope with non-deterministic environments.

**Recursive Coupling Mechanism:**
When the ReAct engine encounters complex sub-problems beyond its current capabilities, it can dynamically trigger the Plan engine for **Sub-planning**. Conversely, every leaf node task generated by the Plan engine is executed by the ReAct engine. This recursive mechanism supports fractal expansion of tasks, adapting to business scenarios of arbitrary complexity.

[Image: Recursive Dual-Engine Architecture Diagram]

## Data Flow and Interaction

Memfit AI's data flow is a complex network supporting bidirectional interaction and dynamic branching, intelligently adapting control flows based on user entry points.

### Dual-Mode User Entry

1.  **Coordinator Entry (Plan-Execute Mode):**
    *   **Scenario:** Vague or complex tasks (e.g., "Comprehensive security audit").
    *   **Flow:** User -> Coordinator -> Planning Loop (Task Tree) -> Review -> Runtime -> ReAct Loops.
    *   **Interaction:** Includes **Planning Review** (user approves/modifies the plan) and **Global Interrupt**.

2.  **ReAct Entry (Instant Execution Mode):**
    *   **Scenario:** Clear, atomic instructions (e.g., "Scan specific IP").
    *   **Flow:** User -> ReAct Loop -> Thought -> Action -> Observation.
    *   **Interaction:** Includes **Ask for Clarification** (when information is missing) and **Action Confirmation** (for sensitive operations).

### Core Data Flow Loop

Regardless of the entry point, data flows through a closed loop:
1.  **Context Construction:** Input (Query + History) is augmented by **Memory Triage** (long-term memory) and **RAG System** (domain knowledge).
2.  **Decision Making:** LLM outputs structured instructions (Plan or ReAct Action) based on the context.
3.  **Execution & Interaction:** Tools are invoked (local or MCP), or human-machine collaboration is triggered.
4.  **Feedback & Learning:** Tool outputs provide short-term feedback; Memory Triage asynchronously analyzes traces for long-term sedimentation into the vector database.

## Key Components

[Image: Key Components Relationship Diagram]

### Coordinator and ReActLoop

*   **Coordinator:** Acts as the system bus and lifecycle manager. It manages session context, loads configurations, and serves as the bridge between user intent and system execution. It maintains the global task state machine and monitors subtask execution.
*   **ReActLoop:** The minimal execution unit. It drives the "Reasoning-Acting" cycle within an independent context. It supports **Dynamic Suspension** to request help or new plans, and seamless switching to Plan mode.

### ReAct Loops (Execution Engine)

Each ReAct Loop is a scalable state machine execution environment.
*   **Anatomy:** Consists of a **LoopEngine** (state flow), **Action Registry** (custom actions), and **Prompt Manager** (context generation).
*   **Focus Mode:** Allows defining specific modes (e.g., Code Audit). A Loop can be encapsulated as an Action, allowing the Agent to push the current context and start a specialized sub-Loop.
*   **Reliability:** Includes **SelfReflection** (analyzes failures) and **Spin Detector** (prevents infinite loops in actions or logic).

### Tools & Forges (Capability Layer)

[Image: Tools and Forges Diagram]

*   **Tools:** Standardized atomic capabilities (e.g., "ReadFile", "ShellExec"). Supports **MCP** (Model Context Protocol), **Yaklang Native** tools, and **Agentic Search** for dynamic tool discovery.
*   **Forges:** Scenario-based capability modules (AI Blueprints). A Forge is a collection of Prompts, tools, and logic for a specific domain (e.g., "Java Code Audit Forge"). The Coordinator can instantiate a Forge as a Subtask.

### Memory Triage & RAG System

*   **Memory Triage (Intelligent Hippocampus):** Uses the **C.O.R.E. P.A.C.T. Framework** to assess and score memory fragments (Connectivity, Origin, Relevance, Emotion, Preference, Actionability, Temporality). High-score memories are persisted and indexed for "Potential Questions".
*   **RAG System (External Brain):** An active, agentic knowledge service. Supports **Hybrid Indexing** (Vector + Keyword), **Scalar Filtering**, and **Multi-hop Retrieval**. It fuses Domain Knowledge, Tools/Forges information, and Historical Memories.

## Planning and Execution Closed Loop

Memfit AI operates on a "Plan-Execute-Reflect" closed loop.

### Coordinator Planning Flow

[Image: Coordinator Planning Flow]

1.  **Context Loading:** Initializing context with Memory and RAG.
2.  **Plan Generation:** A planning-specific ReAct Loop generates the **AiTask** tree.
3.  **Human-in-the-Loop Review:** User reviews, modifies, or approves the plan.
4.  **Runtime Dispatch:** The Scheduler instantiates ReAct Loops for leaf nodes.

### ReAct Execution Flow

[Image: ReAct Execution Flow]

Follows the **OODA (Observe-Orient-Decide-Act)** loop:
1.  **Observation:** Collect environment state and feedback.
2.  **Reasoning:** LLM reasons with Spin Detection checks.
3.  **Action Dispatch:** LLM outputs actions; sensitive operations undergo permission review.
4.  **Feedback:** Execution results drive the next iteration.

### Reliability Assurance

*   **Self-Reflection:** Triggered by errors or excessive steps. Analyzes failure causes and generates a Correction Plan for the next prompt.
*   **Spin Detection:** Detects **Action Spin** (repeated parameters) and **Logic Spin** (semantic repetition). Intervenes with interference info or forced reflection.
*   **Memory-Augmented Recovery:** Retrieves similar historical error cases to assist in current decision-making.

