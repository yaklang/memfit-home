---
sidebar_position: 1
title: 概览
---

# Memfit AI 概览

## 什么是 Memfit AI？

Memfit AI 是一个专为网络安全领域设计的智能代理系统，由 **Yaklang** 生态系统驱动。它超越了简单的聊天机器人，实现了一种 **递归式双引擎架构 (Recursive Dual-Engine Architecture)**，将宏观的战略规划与微观的战术执行完美结合。

Memfit AI 的核心是作为高层人类意图（如“审计此网站”）与底层安全操作（如端口扫描、漏洞分析）之间的桥梁。它通过有机融合以下两点来实现这一目标：
*   **确定性 (Determinism)：** 针对复杂工作流的结构化规划。
*   **灵活性 (Flexibility)：** 针对动态环境的自适应执行。

![Memfit AI Concept](/img/memfit-ai-concept.jpg)

## 解决了什么问题？

传统的 AI Agent 通常面临“单一范式困境”：
*   **纯 ReAct Agent** 容易在长链路任务中迷失方向，在多步操作后忘记最初的目标。
*   **纯 Plan-Execute Agent** 过于僵化，当初步计划遇到意外障碍或新信息时往往会失败。

Memfit AI 通过 **递归耦合** 这两种范式解决了这个问题。它制定计划，执行计划，如果某个子任务变得过于复杂，它会递归地触发一个新的规划阶段。这使得它能够处理任意复杂度的任务，同时适应实时反馈。

---

## 核心架构：五大支柱

Memfit AI 围绕五个关键组件构建，它们协同工作以提供智能安全能力。

![Memfit AI Architecture Pillars](/img/memfit-5-pillars.jpg)

### 1. Plan 引擎 (战略层)

**要解决的问题：**
复杂的安全任务（如“渗透测试”）无法一步完成。它们需要一个路线图来确保覆盖范围和逻辑推进。

**解决方案：**
Plan 引擎充当战略家。它将模糊的顶层用户目标拆解为结构化的 **任务树 (Task Tree)**。它预测依赖关系（例如，“在识别服务之前先扫描端口”）并设定执行顺序。

**技术架构：**
*   **任务树生成：** 将目标解构为分层子任务。
*   **依赖管理：** 强制执行时序和逻辑顺序。
*   **递归触发：** 当子任务过于复杂时，可由 ReAct 引擎反向调用。

### 2. ReAct 引擎 (战术层)

**要解决的问题：**
现实世界是非确定性的。扫描器可能会超时，端口可能会关闭，或者可能会发现新的漏洞。静态脚本无法适应这些变化。

**解决方案：**
ReAct 引擎处理执行的“最后一公里”。对于计划中的每个原子任务，它启动一个独立的 **观察-思考-行动 (Observation-Thought-Action)** 循环。它感知环境，推理当前状态，并选择最佳的下一步行动。

**技术架构：**
*   **LoopEngine：** 管理 OODA (观察-调整-决策-行动) 循环。
*   **自旋检测 (Spin Detection)：** 防止 Agent 陷入死循环（例如，无休止地重试失败的命令）。
*   **自我反思 (Self-Reflection)：** 分析失败原因并自动生成修正计划。

### 3. 工具与 Forges (能力层)

**要解决的问题：**
AI 模型是“缸中之脑”——它无法直接接触网络或文件系统。它需要专门的接口来与网络安全世界交互。

**解决方案：**
*   **工具 (Tools)：** 标准化的原子能力（例如 `PortScan`、`ReadFile`、`HttpReq`）。
*   **Forges：** 场景化的“蓝图”，打包了特定领域的提示词、工具和逻辑（例如“Java 代码审计 Forge”）。

**技术架构：**
*   **Yaklang 集成：** 原生利用 Yaklang 强大的安全库。
*   **MCP 支持：** 兼容 Model Context Protocol 以实现扩展性。
*   **专注模式 (Focus Mode)：** 允许为特定子任务实例化专门的环境。

### 4. 知识 (RAG 系统)

**要解决的问题：**
LLM 有训练截止日期，且缺乏私有或高度特定的领域知识（例如，最新的 CVE 详情或内部 API 文档）。

**解决方案：**
RAG（检索增强生成）系统充当主动的“外脑”。它检索相关的文档、过往报告和安全知识，使 AI 的推理基于事实。

**技术架构：**
*   **混合索引：** 结合向量搜索（语义）和关键词搜索（精确）。
*   **代理化检索：** 系统主动决定 *何时* 以及 *搜索什么*，而不仅仅是被动地检索上下文。

### 5. 记忆 (上下文层)

**要解决的问题：**
标准的 LLM 会话是无状态的。Agent 会忘记之前的审计中发生了什么，或者用户的偏好是什么，导致重复性错误。

**解决方案：**
记忆系统充当“智能海马体”。它不仅存储日志；它还评估、评分和索引经历。成功的策略被记住；失败被存储为“吸取的教训”。

**技术架构：**
*   **C.O.R.E. P.A.C.T. 框架：** 一个评分系统，用于确定哪些记忆值得保留（关联度、相关性、可操作性等）。
*   **向量数据库：** 持久化高价值记忆，以便跨会话长期调用。
